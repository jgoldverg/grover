// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v5.29.3
// source: transfer.proto

package pb

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type ProtocolType int32

const (
	ProtocolType_PROTOCOL_TYPE_UNSPECIFIED ProtocolType = 0
	ProtocolType_PROTOCOL_TYPE_LOCAL       ProtocolType = 1
	ProtocolType_PROTOCOL_TYPE_FTP         ProtocolType = 2
	ProtocolType_PROTOCOL_TYPE_FTPS        ProtocolType = 3
	ProtocolType_PROTOCOL_TYPE_SFTP        ProtocolType = 4
	ProtocolType_PROTOCOL_TYPE_HTTP        ProtocolType = 5
	ProtocolType_PROTOCOL_TYPE_HTTPS       ProtocolType = 6
	ProtocolType_PROTOCOL_TYPE_GDRIVE      ProtocolType = 7
)

// Enum value maps for ProtocolType.
var (
	ProtocolType_name = map[int32]string{
		0: "PROTOCOL_TYPE_UNSPECIFIED",
		1: "PROTOCOL_TYPE_LOCAL",
		2: "PROTOCOL_TYPE_FTP",
		3: "PROTOCOL_TYPE_FTPS",
		4: "PROTOCOL_TYPE_SFTP",
		5: "PROTOCOL_TYPE_HTTP",
		6: "PROTOCOL_TYPE_HTTPS",
		7: "PROTOCOL_TYPE_GDRIVE",
	}
	ProtocolType_value = map[string]int32{
		"PROTOCOL_TYPE_UNSPECIFIED": 0,
		"PROTOCOL_TYPE_LOCAL":       1,
		"PROTOCOL_TYPE_FTP":         2,
		"PROTOCOL_TYPE_FTPS":        3,
		"PROTOCOL_TYPE_SFTP":        4,
		"PROTOCOL_TYPE_HTTP":        5,
		"PROTOCOL_TYPE_HTTPS":       6,
		"PROTOCOL_TYPE_GDRIVE":      7,
	}
)

func (x ProtocolType) Enum() *ProtocolType {
	p := new(ProtocolType)
	*p = x
	return p
}

func (x ProtocolType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ProtocolType) Descriptor() protoreflect.EnumDescriptor {
	return file_transfer_proto_enumTypes[0].Descriptor()
}

func (ProtocolType) Type() protoreflect.EnumType {
	return &file_transfer_proto_enumTypes[0]
}

func (x ProtocolType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ProtocolType.Descriptor instead.
func (ProtocolType) EnumDescriptor() ([]byte, []int) {
	return file_transfer_proto_rawDescGZIP(), []int{0}
}

type TlsConfiguration struct {
	state                protoimpl.MessageState `protogen:"open.v1"`
	Enabled              bool                   `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	CaCertificatePem     []byte                 `protobuf:"bytes,2,opt,name=ca_certificate_pem,json=caCertificatePem,proto3" json:"ca_certificate_pem,omitempty"`
	ClientCertificatePem []byte                 `protobuf:"bytes,3,opt,name=client_certificate_pem,json=clientCertificatePem,proto3" json:"client_certificate_pem,omitempty"`
	ClientKeyPem         []byte                 `protobuf:"bytes,4,opt,name=client_key_pem,json=clientKeyPem,proto3" json:"client_key_pem,omitempty"`
	InsecureSkipVerify   bool                   `protobuf:"varint,5,opt,name=insecure_skip_verify,json=insecureSkipVerify,proto3" json:"insecure_skip_verify,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *TlsConfiguration) Reset() {
	*x = TlsConfiguration{}
	mi := &file_transfer_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TlsConfiguration) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TlsConfiguration) ProtoMessage() {}

func (x *TlsConfiguration) ProtoReflect() protoreflect.Message {
	mi := &file_transfer_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TlsConfiguration.ProtoReflect.Descriptor instead.
func (*TlsConfiguration) Descriptor() ([]byte, []int) {
	return file_transfer_proto_rawDescGZIP(), []int{0}
}

func (x *TlsConfiguration) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *TlsConfiguration) GetCaCertificatePem() []byte {
	if x != nil {
		return x.CaCertificatePem
	}
	return nil
}

func (x *TlsConfiguration) GetClientCertificatePem() []byte {
	if x != nil {
		return x.ClientCertificatePem
	}
	return nil
}

func (x *TlsConfiguration) GetClientKeyPem() []byte {
	if x != nil {
		return x.ClientKeyPem
	}
	return nil
}

func (x *TlsConfiguration) GetInsecureSkipVerify() bool {
	if x != nil {
		return x.InsecureSkipVerify
	}
	return false
}

type CredentialReference struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	CredentialId  string                 `protobuf:"bytes,1,opt,name=credential_id,json=credentialId,proto3" json:"credential_id,omitempty"` // Unique ID for stored credential
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CredentialReference) Reset() {
	*x = CredentialReference{}
	mi := &file_transfer_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CredentialReference) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CredentialReference) ProtoMessage() {}

func (x *CredentialReference) ProtoReflect() protoreflect.Message {
	mi := &file_transfer_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CredentialReference.ProtoReflect.Descriptor instead.
func (*CredentialReference) Descriptor() ([]byte, []int) {
	return file_transfer_proto_rawDescGZIP(), []int{1}
}

func (x *CredentialReference) GetCredentialId() string {
	if x != nil {
		return x.CredentialId
	}
	return ""
}

type Credential struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Id    string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Types that are valid to be assigned to CredentialType:
	//
	//	*Credential_Ssh
	//	*Credential_Basic
	//	*Credential_Jwt
	CredentialType isCredential_CredentialType `protobuf_oneof:"credential_type"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *Credential) Reset() {
	*x = Credential{}
	mi := &file_transfer_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Credential) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Credential) ProtoMessage() {}

func (x *Credential) ProtoReflect() protoreflect.Message {
	mi := &file_transfer_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Credential.ProtoReflect.Descriptor instead.
func (*Credential) Descriptor() ([]byte, []int) {
	return file_transfer_proto_rawDescGZIP(), []int{2}
}

func (x *Credential) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Credential) GetCredentialType() isCredential_CredentialType {
	if x != nil {
		return x.CredentialType
	}
	return nil
}

func (x *Credential) GetSsh() *SshCredential {
	if x != nil {
		if x, ok := x.CredentialType.(*Credential_Ssh); ok {
			return x.Ssh
		}
	}
	return nil
}

func (x *Credential) GetBasic() *BasicCredential {
	if x != nil {
		if x, ok := x.CredentialType.(*Credential_Basic); ok {
			return x.Basic
		}
	}
	return nil
}

func (x *Credential) GetJwt() *JwtCredential {
	if x != nil {
		if x, ok := x.CredentialType.(*Credential_Jwt); ok {
			return x.Jwt
		}
	}
	return nil
}

type isCredential_CredentialType interface {
	isCredential_CredentialType()
}

type Credential_Ssh struct {
	Ssh *SshCredential `protobuf:"bytes,2,opt,name=ssh,proto3,oneof"`
}

type Credential_Basic struct {
	Basic *BasicCredential `protobuf:"bytes,3,opt,name=basic,proto3,oneof"`
}

type Credential_Jwt struct {
	Jwt *JwtCredential `protobuf:"bytes,4,opt,name=jwt,proto3,oneof"`
}

func (*Credential_Ssh) isCredential_CredentialType() {}

func (*Credential_Basic) isCredential_CredentialType() {}

func (*Credential_Jwt) isCredential_CredentialType() {}

type SshCredential struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	PrivateKeyPem []byte                 `protobuf:"bytes,1,opt,name=private_key_pem,json=privateKeyPem,proto3" json:"private_key_pem,omitempty"`
	Passphrase    string                 `protobuf:"bytes,2,opt,name=passphrase,proto3" json:"passphrase,omitempty"`
	PublicKeyPem  []byte                 `protobuf:"bytes,3,opt,name=public_key_pem,json=publicKeyPem,proto3" json:"public_key_pem,omitempty"`
	Username      string                 `protobuf:"bytes,4,opt,name=username,proto3" json:"username,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SshCredential) Reset() {
	*x = SshCredential{}
	mi := &file_transfer_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SshCredential) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SshCredential) ProtoMessage() {}

func (x *SshCredential) ProtoReflect() protoreflect.Message {
	mi := &file_transfer_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SshCredential.ProtoReflect.Descriptor instead.
func (*SshCredential) Descriptor() ([]byte, []int) {
	return file_transfer_proto_rawDescGZIP(), []int{3}
}

func (x *SshCredential) GetPrivateKeyPem() []byte {
	if x != nil {
		return x.PrivateKeyPem
	}
	return nil
}

func (x *SshCredential) GetPassphrase() string {
	if x != nil {
		return x.Passphrase
	}
	return ""
}

func (x *SshCredential) GetPublicKeyPem() []byte {
	if x != nil {
		return x.PublicKeyPem
	}
	return nil
}

func (x *SshCredential) GetUsername() string {
	if x != nil {
		return x.Username
	}
	return ""
}

type BasicCredential struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Username      string                 `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	Password      string                 `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BasicCredential) Reset() {
	*x = BasicCredential{}
	mi := &file_transfer_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BasicCredential) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BasicCredential) ProtoMessage() {}

func (x *BasicCredential) ProtoReflect() protoreflect.Message {
	mi := &file_transfer_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BasicCredential.ProtoReflect.Descriptor instead.
func (*BasicCredential) Descriptor() ([]byte, []int) {
	return file_transfer_proto_rawDescGZIP(), []int{4}
}

func (x *BasicCredential) GetUsername() string {
	if x != nil {
		return x.Username
	}
	return ""
}

func (x *BasicCredential) GetPassword() string {
	if x != nil {
		return x.Password
	}
	return ""
}

type JwtCredential struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Token         string                 `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *JwtCredential) Reset() {
	*x = JwtCredential{}
	mi := &file_transfer_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *JwtCredential) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*JwtCredential) ProtoMessage() {}

func (x *JwtCredential) ProtoReflect() protoreflect.Message {
	mi := &file_transfer_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use JwtCredential.ProtoReflect.Descriptor instead.
func (*JwtCredential) Descriptor() ([]byte, []int) {
	return file_transfer_proto_rawDescGZIP(), []int{5}
}

func (x *JwtCredential) GetToken() string {
	if x != nil {
		return x.Token
	}
	return ""
}

type BackendReference struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Protocol      ProtocolType           `protobuf:"varint,1,opt,name=protocol,proto3,enum=connector.ProtocolType" json:"protocol,omitempty"`
	ConnectionUrl string                 `protobuf:"bytes,2,opt,name=connection_url,json=connectionUrl,proto3" json:"connection_url,omitempty"`
	BackendName   string                 `protobuf:"bytes,3,opt,name=backend_name,json=backendName,proto3" json:"backend_name,omitempty"`
	Credential    *CredentialReference   `protobuf:"bytes,4,opt,name=credential,proto3" json:"credential,omitempty"`
	TlsConfig     *TlsConfiguration      `protobuf:"bytes,5,opt,name=tls_config,json=tlsConfig,proto3" json:"tls_config,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BackendReference) Reset() {
	*x = BackendReference{}
	mi := &file_transfer_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BackendReference) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BackendReference) ProtoMessage() {}

func (x *BackendReference) ProtoReflect() protoreflect.Message {
	mi := &file_transfer_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BackendReference.ProtoReflect.Descriptor instead.
func (*BackendReference) Descriptor() ([]byte, []int) {
	return file_transfer_proto_rawDescGZIP(), []int{6}
}

func (x *BackendReference) GetProtocol() ProtocolType {
	if x != nil {
		return x.Protocol
	}
	return ProtocolType_PROTOCOL_TYPE_UNSPECIFIED
}

func (x *BackendReference) GetConnectionUrl() string {
	if x != nil {
		return x.ConnectionUrl
	}
	return ""
}

func (x *BackendReference) GetBackendName() string {
	if x != nil {
		return x.BackendName
	}
	return ""
}

func (x *BackendReference) GetCredential() *CredentialReference {
	if x != nil {
		return x.Credential
	}
	return nil
}

func (x *BackendReference) GetTlsConfig() *TlsConfiguration {
	if x != nil {
		return x.TlsConfig
	}
	return nil
}

type FileMetadata struct {
	state                protoimpl.MessageState `protogen:"open.v1"`
	FileName             string                 `protobuf:"bytes,1,opt,name=file_name,json=fileName,proto3" json:"file_name,omitempty"`
	FileSizeBytes        int64                  `protobuf:"varint,2,opt,name=file_size_bytes,json=fileSizeBytes,proto3" json:"file_size_bytes,omitempty"`
	IsDirectory          bool                   `protobuf:"varint,3,opt,name=is_directory,json=isDirectory,proto3" json:"is_directory,omitempty"`
	ModificationTimeUnix int64                  `protobuf:"varint,4,opt,name=modification_time_unix,json=modificationTimeUnix,proto3" json:"modification_time_unix,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *FileMetadata) Reset() {
	*x = FileMetadata{}
	mi := &file_transfer_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FileMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FileMetadata) ProtoMessage() {}

func (x *FileMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_transfer_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FileMetadata.ProtoReflect.Descriptor instead.
func (*FileMetadata) Descriptor() ([]byte, []int) {
	return file_transfer_proto_rawDescGZIP(), []int{7}
}

func (x *FileMetadata) GetFileName() string {
	if x != nil {
		return x.FileName
	}
	return ""
}

func (x *FileMetadata) GetFileSizeBytes() int64 {
	if x != nil {
		return x.FileSizeBytes
	}
	return 0
}

func (x *FileMetadata) GetIsDirectory() bool {
	if x != nil {
		return x.IsDirectory
	}
	return false
}

func (x *FileMetadata) GetModificationTimeUnix() int64 {
	if x != nil {
		return x.ModificationTimeUnix
	}
	return 0
}

type FileTransferMetadata struct {
	state                 protoimpl.MessageState `protogen:"open.v1"`
	SourceFilePath        string                 `protobuf:"bytes,1,opt,name=source_file_path,json=sourceFilePath,proto3" json:"source_file_path,omitempty"`
	DestinationFilePath   string                 `protobuf:"bytes,2,opt,name=destination_file_path,json=destinationFilePath,proto3" json:"destination_file_path,omitempty"`
	SourceServerName      string                 `protobuf:"bytes,3,opt,name=source_server_name,json=sourceServerName,proto3" json:"source_server_name,omitempty"`
	DestinationServerName string                 `protobuf:"bytes,4,opt,name=destination_server_name,json=destinationServerName,proto3" json:"destination_server_name,omitempty"`
	SourceBackend         *BackendReference      `protobuf:"bytes,5,opt,name=source_backend,json=sourceBackend,proto3" json:"source_backend,omitempty"`
	DestinationBackend    *BackendReference      `protobuf:"bytes,6,opt,name=destination_backend,json=destinationBackend,proto3" json:"destination_backend,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *FileTransferMetadata) Reset() {
	*x = FileTransferMetadata{}
	mi := &file_transfer_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FileTransferMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FileTransferMetadata) ProtoMessage() {}

func (x *FileTransferMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_transfer_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FileTransferMetadata.ProtoReflect.Descriptor instead.
func (*FileTransferMetadata) Descriptor() ([]byte, []int) {
	return file_transfer_proto_rawDescGZIP(), []int{8}
}

func (x *FileTransferMetadata) GetSourceFilePath() string {
	if x != nil {
		return x.SourceFilePath
	}
	return ""
}

func (x *FileTransferMetadata) GetDestinationFilePath() string {
	if x != nil {
		return x.DestinationFilePath
	}
	return ""
}

func (x *FileTransferMetadata) GetSourceServerName() string {
	if x != nil {
		return x.SourceServerName
	}
	return ""
}

func (x *FileTransferMetadata) GetDestinationServerName() string {
	if x != nil {
		return x.DestinationServerName
	}
	return ""
}

func (x *FileTransferMetadata) GetSourceBackend() *BackendReference {
	if x != nil {
		return x.SourceBackend
	}
	return nil
}

func (x *FileTransferMetadata) GetDestinationBackend() *BackendReference {
	if x != nil {
		return x.DestinationBackend
	}
	return nil
}

type FileChunkMetadata struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	ChunkId         string                 `protobuf:"bytes,1,opt,name=chunk_id,json=chunkId,proto3" json:"chunk_id,omitempty"`
	StartByteIndex  int64                  `protobuf:"varint,2,opt,name=start_byte_index,json=startByteIndex,proto3" json:"start_byte_index,omitempty"`
	EndByteIndex    int64                  `protobuf:"varint,3,opt,name=end_byte_index,json=endByteIndex,proto3" json:"end_byte_index,omitempty"`
	ChunkSizeBytes  int64                  `protobuf:"varint,4,opt,name=chunk_size_bytes,json=chunkSizeBytes,proto3" json:"chunk_size_bytes,omitempty"`
	DirectAccessUrl string                 `protobuf:"bytes,5,opt,name=direct_access_url,json=directAccessUrl,proto3" json:"direct_access_url,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *FileChunkMetadata) Reset() {
	*x = FileChunkMetadata{}
	mi := &file_transfer_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FileChunkMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FileChunkMetadata) ProtoMessage() {}

func (x *FileChunkMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_transfer_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FileChunkMetadata.ProtoReflect.Descriptor instead.
func (*FileChunkMetadata) Descriptor() ([]byte, []int) {
	return file_transfer_proto_rawDescGZIP(), []int{9}
}

func (x *FileChunkMetadata) GetChunkId() string {
	if x != nil {
		return x.ChunkId
	}
	return ""
}

func (x *FileChunkMetadata) GetStartByteIndex() int64 {
	if x != nil {
		return x.StartByteIndex
	}
	return 0
}

func (x *FileChunkMetadata) GetEndByteIndex() int64 {
	if x != nil {
		return x.EndByteIndex
	}
	return 0
}

func (x *FileChunkMetadata) GetChunkSizeBytes() int64 {
	if x != nil {
		return x.ChunkSizeBytes
	}
	return 0
}

func (x *FileChunkMetadata) GetDirectAccessUrl() string {
	if x != nil {
		return x.DirectAccessUrl
	}
	return ""
}

type FileDataPart struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ChunkId       string                 `protobuf:"bytes,1,opt,name=chunk_id,json=chunkId,proto3" json:"chunk_id,omitempty"`
	OffsetInChunk int64                  `protobuf:"varint,2,opt,name=offset_in_chunk,json=offsetInChunk,proto3" json:"offset_in_chunk,omitempty"`
	Data          []byte                 `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FileDataPart) Reset() {
	*x = FileDataPart{}
	mi := &file_transfer_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FileDataPart) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FileDataPart) ProtoMessage() {}

func (x *FileDataPart) ProtoReflect() protoreflect.Message {
	mi := &file_transfer_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FileDataPart.ProtoReflect.Descriptor instead.
func (*FileDataPart) Descriptor() ([]byte, []int) {
	return file_transfer_proto_rawDescGZIP(), []int{10}
}

func (x *FileDataPart) GetChunkId() string {
	if x != nil {
		return x.ChunkId
	}
	return ""
}

func (x *FileDataPart) GetOffsetInChunk() int64 {
	if x != nil {
		return x.OffsetInChunk
	}
	return 0
}

func (x *FileDataPart) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

type OperationStatus struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OperationStatus) Reset() {
	*x = OperationStatus{}
	mi := &file_transfer_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OperationStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OperationStatus) ProtoMessage() {}

func (x *OperationStatus) ProtoReflect() protoreflect.Message {
	mi := &file_transfer_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OperationStatus.ProtoReflect.Descriptor instead.
func (*OperationStatus) Descriptor() ([]byte, []int) {
	return file_transfer_proto_rawDescGZIP(), []int{11}
}

func (x *OperationStatus) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *OperationStatus) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

type SourceTransferEndpoint struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Backend       *BackendReference      `protobuf:"bytes,1,opt,name=backend,proto3" json:"backend,omitempty"`
	FilePath      string                 `protobuf:"bytes,2,opt,name=file_path,json=filePath,proto3" json:"file_path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SourceTransferEndpoint) Reset() {
	*x = SourceTransferEndpoint{}
	mi := &file_transfer_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SourceTransferEndpoint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SourceTransferEndpoint) ProtoMessage() {}

func (x *SourceTransferEndpoint) ProtoReflect() protoreflect.Message {
	mi := &file_transfer_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SourceTransferEndpoint.ProtoReflect.Descriptor instead.
func (*SourceTransferEndpoint) Descriptor() ([]byte, []int) {
	return file_transfer_proto_rawDescGZIP(), []int{12}
}

func (x *SourceTransferEndpoint) GetBackend() *BackendReference {
	if x != nil {
		return x.Backend
	}
	return nil
}

func (x *SourceTransferEndpoint) GetFilePath() string {
	if x != nil {
		return x.FilePath
	}
	return ""
}

type DestinationTransferEndpoint struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Backend       *BackendReference      `protobuf:"bytes,1,opt,name=backend,proto3" json:"backend,omitempty"`
	FilePath      string                 `protobuf:"bytes,2,opt,name=file_path,json=filePath,proto3" json:"file_path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DestinationTransferEndpoint) Reset() {
	*x = DestinationTransferEndpoint{}
	mi := &file_transfer_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DestinationTransferEndpoint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DestinationTransferEndpoint) ProtoMessage() {}

func (x *DestinationTransferEndpoint) ProtoReflect() protoreflect.Message {
	mi := &file_transfer_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DestinationTransferEndpoint.ProtoReflect.Descriptor instead.
func (*DestinationTransferEndpoint) Descriptor() ([]byte, []int) {
	return file_transfer_proto_rawDescGZIP(), []int{13}
}

func (x *DestinationTransferEndpoint) GetBackend() *BackendReference {
	if x != nil {
		return x.Backend
	}
	return nil
}

func (x *DestinationTransferEndpoint) GetFilePath() string {
	if x != nil {
		return x.FilePath
	}
	return ""
}

type TransferEndpoint struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to EndpointType:
	//
	//	*TransferEndpoint_Source
	//	*TransferEndpoint_Destination
	EndpointType  isTransferEndpoint_EndpointType `protobuf_oneof:"endpoint_type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TransferEndpoint) Reset() {
	*x = TransferEndpoint{}
	mi := &file_transfer_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TransferEndpoint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TransferEndpoint) ProtoMessage() {}

func (x *TransferEndpoint) ProtoReflect() protoreflect.Message {
	mi := &file_transfer_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TransferEndpoint.ProtoReflect.Descriptor instead.
func (*TransferEndpoint) Descriptor() ([]byte, []int) {
	return file_transfer_proto_rawDescGZIP(), []int{14}
}

func (x *TransferEndpoint) GetEndpointType() isTransferEndpoint_EndpointType {
	if x != nil {
		return x.EndpointType
	}
	return nil
}

func (x *TransferEndpoint) GetSource() *SourceTransferEndpoint {
	if x != nil {
		if x, ok := x.EndpointType.(*TransferEndpoint_Source); ok {
			return x.Source
		}
	}
	return nil
}

func (x *TransferEndpoint) GetDestination() *DestinationTransferEndpoint {
	if x != nil {
		if x, ok := x.EndpointType.(*TransferEndpoint_Destination); ok {
			return x.Destination
		}
	}
	return nil
}

type isTransferEndpoint_EndpointType interface {
	isTransferEndpoint_EndpointType()
}

type TransferEndpoint_Source struct {
	Source *SourceTransferEndpoint `protobuf:"bytes,1,opt,name=source,proto3,oneof"`
}

type TransferEndpoint_Destination struct {
	Destination *DestinationTransferEndpoint `protobuf:"bytes,2,opt,name=destination,proto3,oneof"`
}

func (*TransferEndpoint_Source) isTransferEndpoint_EndpointType() {}

func (*TransferEndpoint_Destination) isTransferEndpoint_EndpointType() {}

type FileDestinationAssignment struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	FilePath      string                 `protobuf:"bytes,1,opt,name=file_path,json=filePath,proto3" json:"file_path,omitempty"` // Path of the file (relative to root)
	Destination   *TransferEndpoint      `protobuf:"bytes,2,opt,name=destination,proto3" json:"destination,omitempty"`           // Where this file should be copied/scattered to
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FileDestinationAssignment) Reset() {
	*x = FileDestinationAssignment{}
	mi := &file_transfer_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FileDestinationAssignment) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FileDestinationAssignment) ProtoMessage() {}

func (x *FileDestinationAssignment) ProtoReflect() protoreflect.Message {
	mi := &file_transfer_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FileDestinationAssignment.ProtoReflect.Descriptor instead.
func (*FileDestinationAssignment) Descriptor() ([]byte, []int) {
	return file_transfer_proto_rawDescGZIP(), []int{15}
}

func (x *FileDestinationAssignment) GetFilePath() string {
	if x != nil {
		return x.FilePath
	}
	return ""
}

func (x *FileDestinationAssignment) GetDestination() *TransferEndpoint {
	if x != nil {
		return x.Destination
	}
	return nil
}

type FileSourceAssignment struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	FilePath      string                 `protobuf:"bytes,1,opt,name=file_path,json=filePath,proto3" json:"file_path,omitempty"` // File to gather
	Source        *TransferEndpoint      `protobuf:"bytes,2,opt,name=source,proto3" json:"source,omitempty"`                     // Where to gather this file from
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FileSourceAssignment) Reset() {
	*x = FileSourceAssignment{}
	mi := &file_transfer_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FileSourceAssignment) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FileSourceAssignment) ProtoMessage() {}

func (x *FileSourceAssignment) ProtoReflect() protoreflect.Message {
	mi := &file_transfer_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FileSourceAssignment.ProtoReflect.Descriptor instead.
func (*FileSourceAssignment) Descriptor() ([]byte, []int) {
	return file_transfer_proto_rawDescGZIP(), []int{16}
}

func (x *FileSourceAssignment) GetFilePath() string {
	if x != nil {
		return x.FilePath
	}
	return ""
}

func (x *FileSourceAssignment) GetSource() *TransferEndpoint {
	if x != nil {
		return x.Source
	}
	return nil
}

type ListDirectoryRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Backend       *BackendReference      `protobuf:"bytes,1,opt,name=backend,proto3" json:"backend,omitempty"`
	DirectoryPath string                 `protobuf:"bytes,2,opt,name=directory_path,json=directoryPath,proto3" json:"directory_path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListDirectoryRequest) Reset() {
	*x = ListDirectoryRequest{}
	mi := &file_transfer_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListDirectoryRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListDirectoryRequest) ProtoMessage() {}

func (x *ListDirectoryRequest) ProtoReflect() protoreflect.Message {
	mi := &file_transfer_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListDirectoryRequest.ProtoReflect.Descriptor instead.
func (*ListDirectoryRequest) Descriptor() ([]byte, []int) {
	return file_transfer_proto_rawDescGZIP(), []int{17}
}

func (x *ListDirectoryRequest) GetBackend() *BackendReference {
	if x != nil {
		return x.Backend
	}
	return nil
}

func (x *ListDirectoryRequest) GetDirectoryPath() string {
	if x != nil {
		return x.DirectoryPath
	}
	return ""
}

type ListDirectoryResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Files         []*FileMetadata        `protobuf:"bytes,1,rep,name=files,proto3" json:"files,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListDirectoryResponse) Reset() {
	*x = ListDirectoryResponse{}
	mi := &file_transfer_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListDirectoryResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListDirectoryResponse) ProtoMessage() {}

func (x *ListDirectoryResponse) ProtoReflect() protoreflect.Message {
	mi := &file_transfer_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListDirectoryResponse.ProtoReflect.Descriptor instead.
func (*ListDirectoryResponse) Descriptor() ([]byte, []int) {
	return file_transfer_proto_rawDescGZIP(), []int{18}
}

func (x *ListDirectoryResponse) GetFiles() []*FileMetadata {
	if x != nil {
		return x.Files
	}
	return nil
}

type CreateDirectoryRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Backend       *BackendReference      `protobuf:"bytes,1,opt,name=backend,proto3" json:"backend,omitempty"`
	DirectoryPath string                 `protobuf:"bytes,2,opt,name=directory_path,json=directoryPath,proto3" json:"directory_path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateDirectoryRequest) Reset() {
	*x = CreateDirectoryRequest{}
	mi := &file_transfer_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateDirectoryRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateDirectoryRequest) ProtoMessage() {}

func (x *CreateDirectoryRequest) ProtoReflect() protoreflect.Message {
	mi := &file_transfer_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateDirectoryRequest.ProtoReflect.Descriptor instead.
func (*CreateDirectoryRequest) Descriptor() ([]byte, []int) {
	return file_transfer_proto_rawDescGZIP(), []int{19}
}

func (x *CreateDirectoryRequest) GetBackend() *BackendReference {
	if x != nil {
		return x.Backend
	}
	return nil
}

func (x *CreateDirectoryRequest) GetDirectoryPath() string {
	if x != nil {
		return x.DirectoryPath
	}
	return ""
}

type CreateDirectoryResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Status        *OperationStatus       `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateDirectoryResponse) Reset() {
	*x = CreateDirectoryResponse{}
	mi := &file_transfer_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateDirectoryResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateDirectoryResponse) ProtoMessage() {}

func (x *CreateDirectoryResponse) ProtoReflect() protoreflect.Message {
	mi := &file_transfer_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateDirectoryResponse.ProtoReflect.Descriptor instead.
func (*CreateDirectoryResponse) Descriptor() ([]byte, []int) {
	return file_transfer_proto_rawDescGZIP(), []int{20}
}

func (x *CreateDirectoryResponse) GetStatus() *OperationStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

type DeleteFileOrDirectoryRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Backend       *BackendReference      `protobuf:"bytes,1,opt,name=backend,proto3" json:"backend,omitempty"`
	Path          string                 `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteFileOrDirectoryRequest) Reset() {
	*x = DeleteFileOrDirectoryRequest{}
	mi := &file_transfer_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteFileOrDirectoryRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteFileOrDirectoryRequest) ProtoMessage() {}

func (x *DeleteFileOrDirectoryRequest) ProtoReflect() protoreflect.Message {
	mi := &file_transfer_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteFileOrDirectoryRequest.ProtoReflect.Descriptor instead.
func (*DeleteFileOrDirectoryRequest) Descriptor() ([]byte, []int) {
	return file_transfer_proto_rawDescGZIP(), []int{21}
}

func (x *DeleteFileOrDirectoryRequest) GetBackend() *BackendReference {
	if x != nil {
		return x.Backend
	}
	return nil
}

func (x *DeleteFileOrDirectoryRequest) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

type DeleteFileOrDirectoryResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Status        *OperationStatus       `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteFileOrDirectoryResponse) Reset() {
	*x = DeleteFileOrDirectoryResponse{}
	mi := &file_transfer_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteFileOrDirectoryResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteFileOrDirectoryResponse) ProtoMessage() {}

func (x *DeleteFileOrDirectoryResponse) ProtoReflect() protoreflect.Message {
	mi := &file_transfer_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteFileOrDirectoryResponse.ProtoReflect.Descriptor instead.
func (*DeleteFileOrDirectoryResponse) Descriptor() ([]byte, []int) {
	return file_transfer_proto_rawDescGZIP(), []int{22}
}

func (x *DeleteFileOrDirectoryResponse) GetStatus() *OperationStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

type RenameFileOrDirectoryRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Backend       *BackendReference      `protobuf:"bytes,1,opt,name=backend,proto3" json:"backend,omitempty"`
	OldPath       string                 `protobuf:"bytes,2,opt,name=old_path,json=oldPath,proto3" json:"old_path,omitempty"`
	NewPath       string                 `protobuf:"bytes,3,opt,name=new_path,json=newPath,proto3" json:"new_path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RenameFileOrDirectoryRequest) Reset() {
	*x = RenameFileOrDirectoryRequest{}
	mi := &file_transfer_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RenameFileOrDirectoryRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RenameFileOrDirectoryRequest) ProtoMessage() {}

func (x *RenameFileOrDirectoryRequest) ProtoReflect() protoreflect.Message {
	mi := &file_transfer_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RenameFileOrDirectoryRequest.ProtoReflect.Descriptor instead.
func (*RenameFileOrDirectoryRequest) Descriptor() ([]byte, []int) {
	return file_transfer_proto_rawDescGZIP(), []int{23}
}

func (x *RenameFileOrDirectoryRequest) GetBackend() *BackendReference {
	if x != nil {
		return x.Backend
	}
	return nil
}

func (x *RenameFileOrDirectoryRequest) GetOldPath() string {
	if x != nil {
		return x.OldPath
	}
	return ""
}

func (x *RenameFileOrDirectoryRequest) GetNewPath() string {
	if x != nil {
		return x.NewPath
	}
	return ""
}

type RenameFileOrDirectoryResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Status        *OperationStatus       `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RenameFileOrDirectoryResponse) Reset() {
	*x = RenameFileOrDirectoryResponse{}
	mi := &file_transfer_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RenameFileOrDirectoryResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RenameFileOrDirectoryResponse) ProtoMessage() {}

func (x *RenameFileOrDirectoryResponse) ProtoReflect() protoreflect.Message {
	mi := &file_transfer_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RenameFileOrDirectoryResponse.ProtoReflect.Descriptor instead.
func (*RenameFileOrDirectoryResponse) Descriptor() ([]byte, []int) {
	return file_transfer_proto_rawDescGZIP(), []int{24}
}

func (x *RenameFileOrDirectoryResponse) GetStatus() *OperationStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

type ScatterDirectoryRequest struct {
	state                 protoimpl.MessageState       `protogen:"open.v1"`
	Source                *TransferEndpoint            `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`                                                                 // Source directory
	FileAssignments       []*FileDestinationAssignment `protobuf:"bytes,2,rep,name=file_assignments,json=fileAssignments,proto3" json:"file_assignments,omitempty"`                        // Explicit file-to-destination mapping
	DesiredChunkSizeBytes int64                        `protobuf:"varint,3,opt,name=desired_chunk_size_bytes,json=desiredChunkSizeBytes,proto3" json:"desired_chunk_size_bytes,omitempty"` // Optional chunk size for large files
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *ScatterDirectoryRequest) Reset() {
	*x = ScatterDirectoryRequest{}
	mi := &file_transfer_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScatterDirectoryRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScatterDirectoryRequest) ProtoMessage() {}

func (x *ScatterDirectoryRequest) ProtoReflect() protoreflect.Message {
	mi := &file_transfer_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScatterDirectoryRequest.ProtoReflect.Descriptor instead.
func (*ScatterDirectoryRequest) Descriptor() ([]byte, []int) {
	return file_transfer_proto_rawDescGZIP(), []int{25}
}

func (x *ScatterDirectoryRequest) GetSource() *TransferEndpoint {
	if x != nil {
		return x.Source
	}
	return nil
}

func (x *ScatterDirectoryRequest) GetFileAssignments() []*FileDestinationAssignment {
	if x != nil {
		return x.FileAssignments
	}
	return nil
}

func (x *ScatterDirectoryRequest) GetDesiredChunkSizeBytes() int64 {
	if x != nil {
		return x.DesiredChunkSizeBytes
	}
	return 0
}

type ScatterDirectoryResponse struct {
	state              protoimpl.MessageState      `protogen:"open.v1"`
	FileTransferStatus map[string]*OperationStatus `protobuf:"bytes,1,rep,name=file_transfer_status,json=fileTransferStatus,proto3" json:"file_transfer_status,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // file_path -> status
	OverallStatus      *OperationStatus            `protobuf:"bytes,2,opt,name=overall_status,json=overallStatus,proto3" json:"overall_status,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *ScatterDirectoryResponse) Reset() {
	*x = ScatterDirectoryResponse{}
	mi := &file_transfer_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScatterDirectoryResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScatterDirectoryResponse) ProtoMessage() {}

func (x *ScatterDirectoryResponse) ProtoReflect() protoreflect.Message {
	mi := &file_transfer_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScatterDirectoryResponse.ProtoReflect.Descriptor instead.
func (*ScatterDirectoryResponse) Descriptor() ([]byte, []int) {
	return file_transfer_proto_rawDescGZIP(), []int{26}
}

func (x *ScatterDirectoryResponse) GetFileTransferStatus() map[string]*OperationStatus {
	if x != nil {
		return x.FileTransferStatus
	}
	return nil
}

func (x *ScatterDirectoryResponse) GetOverallStatus() *OperationStatus {
	if x != nil {
		return x.OverallStatus
	}
	return nil
}

type GatherDirectoryRequest struct {
	state           protoimpl.MessageState  `protogen:"open.v1"`
	FileAssignments []*FileSourceAssignment `protobuf:"bytes,1,rep,name=file_assignments,json=fileAssignments,proto3" json:"file_assignments,omitempty"` // File-to-source mappings
	Destination     *TransferEndpoint       `protobuf:"bytes,2,opt,name=destination,proto3" json:"destination,omitempty"`                                // Destination backend
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *GatherDirectoryRequest) Reset() {
	*x = GatherDirectoryRequest{}
	mi := &file_transfer_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GatherDirectoryRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GatherDirectoryRequest) ProtoMessage() {}

func (x *GatherDirectoryRequest) ProtoReflect() protoreflect.Message {
	mi := &file_transfer_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GatherDirectoryRequest.ProtoReflect.Descriptor instead.
func (*GatherDirectoryRequest) Descriptor() ([]byte, []int) {
	return file_transfer_proto_rawDescGZIP(), []int{27}
}

func (x *GatherDirectoryRequest) GetFileAssignments() []*FileSourceAssignment {
	if x != nil {
		return x.FileAssignments
	}
	return nil
}

func (x *GatherDirectoryRequest) GetDestination() *TransferEndpoint {
	if x != nil {
		return x.Destination
	}
	return nil
}

type GatherDirectoryResponse struct {
	state            protoimpl.MessageState      `protogen:"open.v1"`
	FileGatherStatus map[string]*OperationStatus `protobuf:"bytes,1,rep,name=file_gather_status,json=fileGatherStatus,proto3" json:"file_gather_status,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // file_path -> status
	OverallStatus    *OperationStatus            `protobuf:"bytes,2,opt,name=overall_status,json=overallStatus,proto3" json:"overall_status,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *GatherDirectoryResponse) Reset() {
	*x = GatherDirectoryResponse{}
	mi := &file_transfer_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GatherDirectoryResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GatherDirectoryResponse) ProtoMessage() {}

func (x *GatherDirectoryResponse) ProtoReflect() protoreflect.Message {
	mi := &file_transfer_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GatherDirectoryResponse.ProtoReflect.Descriptor instead.
func (*GatherDirectoryResponse) Descriptor() ([]byte, []int) {
	return file_transfer_proto_rawDescGZIP(), []int{28}
}

func (x *GatherDirectoryResponse) GetFileGatherStatus() map[string]*OperationStatus {
	if x != nil {
		return x.FileGatherStatus
	}
	return nil
}

func (x *GatherDirectoryResponse) GetOverallStatus() *OperationStatus {
	if x != nil {
		return x.OverallStatus
	}
	return nil
}

type CopyFileRequest struct {
	state               protoimpl.MessageState `protogen:"open.v1"`
	SourceEndpoint      *TransferEndpoint      `protobuf:"bytes,1,opt,name=source_endpoint,json=sourceEndpoint,proto3" json:"source_endpoint,omitempty"`
	DestinationEndpoint *TransferEndpoint      `protobuf:"bytes,2,opt,name=destination_endpoint,json=destinationEndpoint,proto3" json:"destination_endpoint,omitempty"`
	FilePath            string                 `protobuf:"bytes,3,opt,name=file_path,json=filePath,proto3" json:"file_path,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *CopyFileRequest) Reset() {
	*x = CopyFileRequest{}
	mi := &file_transfer_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CopyFileRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CopyFileRequest) ProtoMessage() {}

func (x *CopyFileRequest) ProtoReflect() protoreflect.Message {
	mi := &file_transfer_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CopyFileRequest.ProtoReflect.Descriptor instead.
func (*CopyFileRequest) Descriptor() ([]byte, []int) {
	return file_transfer_proto_rawDescGZIP(), []int{29}
}

func (x *CopyFileRequest) GetSourceEndpoint() *TransferEndpoint {
	if x != nil {
		return x.SourceEndpoint
	}
	return nil
}

func (x *CopyFileRequest) GetDestinationEndpoint() *TransferEndpoint {
	if x != nil {
		return x.DestinationEndpoint
	}
	return nil
}

func (x *CopyFileRequest) GetFilePath() string {
	if x != nil {
		return x.FilePath
	}
	return ""
}

type CopyFileResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Status        *OperationStatus       `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CopyFileResponse) Reset() {
	*x = CopyFileResponse{}
	mi := &file_transfer_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CopyFileResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CopyFileResponse) ProtoMessage() {}

func (x *CopyFileResponse) ProtoReflect() protoreflect.Message {
	mi := &file_transfer_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CopyFileResponse.ProtoReflect.Descriptor instead.
func (*CopyFileResponse) Descriptor() ([]byte, []int) {
	return file_transfer_proto_rawDescGZIP(), []int{30}
}

func (x *CopyFileResponse) GetStatus() *OperationStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

type UploadFileStatus struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Status        *OperationStatus       `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UploadFileStatus) Reset() {
	*x = UploadFileStatus{}
	mi := &file_transfer_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UploadFileStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UploadFileStatus) ProtoMessage() {}

func (x *UploadFileStatus) ProtoReflect() protoreflect.Message {
	mi := &file_transfer_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UploadFileStatus.ProtoReflect.Descriptor instead.
func (*UploadFileStatus) Descriptor() ([]byte, []int) {
	return file_transfer_proto_rawDescGZIP(), []int{31}
}

func (x *UploadFileStatus) GetStatus() *OperationStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

type DownloadFileRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Backend       *BackendReference      `protobuf:"bytes,1,opt,name=backend,proto3" json:"backend,omitempty"`
	FilePath      string                 `protobuf:"bytes,2,opt,name=file_path,json=filePath,proto3" json:"file_path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DownloadFileRequest) Reset() {
	*x = DownloadFileRequest{}
	mi := &file_transfer_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DownloadFileRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DownloadFileRequest) ProtoMessage() {}

func (x *DownloadFileRequest) ProtoReflect() protoreflect.Message {
	mi := &file_transfer_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DownloadFileRequest.ProtoReflect.Descriptor instead.
func (*DownloadFileRequest) Descriptor() ([]byte, []int) {
	return file_transfer_proto_rawDescGZIP(), []int{32}
}

func (x *DownloadFileRequest) GetBackend() *BackendReference {
	if x != nil {
		return x.Backend
	}
	return nil
}

func (x *DownloadFileRequest) GetFilePath() string {
	if x != nil {
		return x.FilePath
	}
	return ""
}

type DownloadFileResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	DataPart      *FileDataPart          `protobuf:"bytes,1,opt,name=data_part,json=dataPart,proto3" json:"data_part,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DownloadFileResponse) Reset() {
	*x = DownloadFileResponse{}
	mi := &file_transfer_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DownloadFileResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DownloadFileResponse) ProtoMessage() {}

func (x *DownloadFileResponse) ProtoReflect() protoreflect.Message {
	mi := &file_transfer_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DownloadFileResponse.ProtoReflect.Descriptor instead.
func (*DownloadFileResponse) Descriptor() ([]byte, []int) {
	return file_transfer_proto_rawDescGZIP(), []int{33}
}

func (x *DownloadFileResponse) GetDataPart() *FileDataPart {
	if x != nil {
		return x.DataPart
	}
	return nil
}

var File_transfer_proto protoreflect.FileDescriptor

const file_transfer_proto_rawDesc = "" +
	"\n" +
	"\x0etransfer.proto\x12\tconnector\"\xe8\x01\n" +
	"\x10TlsConfiguration\x12\x18\n" +
	"\aenabled\x18\x01 \x01(\bR\aenabled\x12,\n" +
	"\x12ca_certificate_pem\x18\x02 \x01(\fR\x10caCertificatePem\x124\n" +
	"\x16client_certificate_pem\x18\x03 \x01(\fR\x14clientCertificatePem\x12$\n" +
	"\x0eclient_key_pem\x18\x04 \x01(\fR\fclientKeyPem\x120\n" +
	"\x14insecure_skip_verify\x18\x05 \x01(\bR\x12insecureSkipVerify\":\n" +
	"\x13CredentialReference\x12#\n" +
	"\rcredential_id\x18\x01 \x01(\tR\fcredentialId\"\xbf\x01\n" +
	"\n" +
	"Credential\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12,\n" +
	"\x03ssh\x18\x02 \x01(\v2\x18.connector.SshCredentialH\x00R\x03ssh\x122\n" +
	"\x05basic\x18\x03 \x01(\v2\x1a.connector.BasicCredentialH\x00R\x05basic\x12,\n" +
	"\x03jwt\x18\x04 \x01(\v2\x18.connector.JwtCredentialH\x00R\x03jwtB\x11\n" +
	"\x0fcredential_type\"\x99\x01\n" +
	"\rSshCredential\x12&\n" +
	"\x0fprivate_key_pem\x18\x01 \x01(\fR\rprivateKeyPem\x12\x1e\n" +
	"\n" +
	"passphrase\x18\x02 \x01(\tR\n" +
	"passphrase\x12$\n" +
	"\x0epublic_key_pem\x18\x03 \x01(\fR\fpublicKeyPem\x12\x1a\n" +
	"\busername\x18\x04 \x01(\tR\busername\"I\n" +
	"\x0fBasicCredential\x12\x1a\n" +
	"\busername\x18\x01 \x01(\tR\busername\x12\x1a\n" +
	"\bpassword\x18\x02 \x01(\tR\bpassword\"%\n" +
	"\rJwtCredential\x12\x14\n" +
	"\x05token\x18\x01 \x01(\tR\x05token\"\x8d\x02\n" +
	"\x10BackendReference\x123\n" +
	"\bprotocol\x18\x01 \x01(\x0e2\x17.connector.ProtocolTypeR\bprotocol\x12%\n" +
	"\x0econnection_url\x18\x02 \x01(\tR\rconnectionUrl\x12!\n" +
	"\fbackend_name\x18\x03 \x01(\tR\vbackendName\x12>\n" +
	"\n" +
	"credential\x18\x04 \x01(\v2\x1e.connector.CredentialReferenceR\n" +
	"credential\x12:\n" +
	"\n" +
	"tls_config\x18\x05 \x01(\v2\x1b.connector.TlsConfigurationR\ttlsConfig\"\xac\x01\n" +
	"\fFileMetadata\x12\x1b\n" +
	"\tfile_name\x18\x01 \x01(\tR\bfileName\x12&\n" +
	"\x0ffile_size_bytes\x18\x02 \x01(\x03R\rfileSizeBytes\x12!\n" +
	"\fis_directory\x18\x03 \x01(\bR\visDirectory\x124\n" +
	"\x16modification_time_unix\x18\x04 \x01(\x03R\x14modificationTimeUnix\"\xec\x02\n" +
	"\x14FileTransferMetadata\x12(\n" +
	"\x10source_file_path\x18\x01 \x01(\tR\x0esourceFilePath\x122\n" +
	"\x15destination_file_path\x18\x02 \x01(\tR\x13destinationFilePath\x12,\n" +
	"\x12source_server_name\x18\x03 \x01(\tR\x10sourceServerName\x126\n" +
	"\x17destination_server_name\x18\x04 \x01(\tR\x15destinationServerName\x12B\n" +
	"\x0esource_backend\x18\x05 \x01(\v2\x1b.connector.BackendReferenceR\rsourceBackend\x12L\n" +
	"\x13destination_backend\x18\x06 \x01(\v2\x1b.connector.BackendReferenceR\x12destinationBackend\"\xd4\x01\n" +
	"\x11FileChunkMetadata\x12\x19\n" +
	"\bchunk_id\x18\x01 \x01(\tR\achunkId\x12(\n" +
	"\x10start_byte_index\x18\x02 \x01(\x03R\x0estartByteIndex\x12$\n" +
	"\x0eend_byte_index\x18\x03 \x01(\x03R\fendByteIndex\x12(\n" +
	"\x10chunk_size_bytes\x18\x04 \x01(\x03R\x0echunkSizeBytes\x12*\n" +
	"\x11direct_access_url\x18\x05 \x01(\tR\x0fdirectAccessUrl\"e\n" +
	"\fFileDataPart\x12\x19\n" +
	"\bchunk_id\x18\x01 \x01(\tR\achunkId\x12&\n" +
	"\x0foffset_in_chunk\x18\x02 \x01(\x03R\roffsetInChunk\x12\x12\n" +
	"\x04data\x18\x03 \x01(\fR\x04data\"E\n" +
	"\x0fOperationStatus\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\"l\n" +
	"\x16SourceTransferEndpoint\x125\n" +
	"\abackend\x18\x01 \x01(\v2\x1b.connector.BackendReferenceR\abackend\x12\x1b\n" +
	"\tfile_path\x18\x02 \x01(\tR\bfilePath\"q\n" +
	"\x1bDestinationTransferEndpoint\x125\n" +
	"\abackend\x18\x01 \x01(\v2\x1b.connector.BackendReferenceR\abackend\x12\x1b\n" +
	"\tfile_path\x18\x02 \x01(\tR\bfilePath\"\xac\x01\n" +
	"\x10TransferEndpoint\x12;\n" +
	"\x06source\x18\x01 \x01(\v2!.connector.SourceTransferEndpointH\x00R\x06source\x12J\n" +
	"\vdestination\x18\x02 \x01(\v2&.connector.DestinationTransferEndpointH\x00R\vdestinationB\x0f\n" +
	"\rendpoint_type\"w\n" +
	"\x19FileDestinationAssignment\x12\x1b\n" +
	"\tfile_path\x18\x01 \x01(\tR\bfilePath\x12=\n" +
	"\vdestination\x18\x02 \x01(\v2\x1b.connector.TransferEndpointR\vdestination\"h\n" +
	"\x14FileSourceAssignment\x12\x1b\n" +
	"\tfile_path\x18\x01 \x01(\tR\bfilePath\x123\n" +
	"\x06source\x18\x02 \x01(\v2\x1b.connector.TransferEndpointR\x06source\"t\n" +
	"\x14ListDirectoryRequest\x125\n" +
	"\abackend\x18\x01 \x01(\v2\x1b.connector.BackendReferenceR\abackend\x12%\n" +
	"\x0edirectory_path\x18\x02 \x01(\tR\rdirectoryPath\"F\n" +
	"\x15ListDirectoryResponse\x12-\n" +
	"\x05files\x18\x01 \x03(\v2\x17.connector.FileMetadataR\x05files\"v\n" +
	"\x16CreateDirectoryRequest\x125\n" +
	"\abackend\x18\x01 \x01(\v2\x1b.connector.BackendReferenceR\abackend\x12%\n" +
	"\x0edirectory_path\x18\x02 \x01(\tR\rdirectoryPath\"M\n" +
	"\x17CreateDirectoryResponse\x122\n" +
	"\x06status\x18\x01 \x01(\v2\x1a.connector.OperationStatusR\x06status\"i\n" +
	"\x1cDeleteFileOrDirectoryRequest\x125\n" +
	"\abackend\x18\x01 \x01(\v2\x1b.connector.BackendReferenceR\abackend\x12\x12\n" +
	"\x04path\x18\x02 \x01(\tR\x04path\"S\n" +
	"\x1dDeleteFileOrDirectoryResponse\x122\n" +
	"\x06status\x18\x01 \x01(\v2\x1a.connector.OperationStatusR\x06status\"\x8b\x01\n" +
	"\x1cRenameFileOrDirectoryRequest\x125\n" +
	"\abackend\x18\x01 \x01(\v2\x1b.connector.BackendReferenceR\abackend\x12\x19\n" +
	"\bold_path\x18\x02 \x01(\tR\aoldPath\x12\x19\n" +
	"\bnew_path\x18\x03 \x01(\tR\anewPath\"S\n" +
	"\x1dRenameFileOrDirectoryResponse\x122\n" +
	"\x06status\x18\x01 \x01(\v2\x1a.connector.OperationStatusR\x06status\"\xd8\x01\n" +
	"\x17ScatterDirectoryRequest\x123\n" +
	"\x06source\x18\x01 \x01(\v2\x1b.connector.TransferEndpointR\x06source\x12O\n" +
	"\x10file_assignments\x18\x02 \x03(\v2$.connector.FileDestinationAssignmentR\x0ffileAssignments\x127\n" +
	"\x18desired_chunk_size_bytes\x18\x03 \x01(\x03R\x15desiredChunkSizeBytes\"\xaf\x02\n" +
	"\x18ScatterDirectoryResponse\x12m\n" +
	"\x14file_transfer_status\x18\x01 \x03(\v2;.connector.ScatterDirectoryResponse.FileTransferStatusEntryR\x12fileTransferStatus\x12A\n" +
	"\x0eoverall_status\x18\x02 \x01(\v2\x1a.connector.OperationStatusR\roverallStatus\x1aa\n" +
	"\x17FileTransferStatusEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x120\n" +
	"\x05value\x18\x02 \x01(\v2\x1a.connector.OperationStatusR\x05value:\x028\x01\"\xa3\x01\n" +
	"\x16GatherDirectoryRequest\x12J\n" +
	"\x10file_assignments\x18\x01 \x03(\v2\x1f.connector.FileSourceAssignmentR\x0ffileAssignments\x12=\n" +
	"\vdestination\x18\x02 \x01(\v2\x1b.connector.TransferEndpointR\vdestination\"\xa5\x02\n" +
	"\x17GatherDirectoryResponse\x12f\n" +
	"\x12file_gather_status\x18\x01 \x03(\v28.connector.GatherDirectoryResponse.FileGatherStatusEntryR\x10fileGatherStatus\x12A\n" +
	"\x0eoverall_status\x18\x02 \x01(\v2\x1a.connector.OperationStatusR\roverallStatus\x1a_\n" +
	"\x15FileGatherStatusEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x120\n" +
	"\x05value\x18\x02 \x01(\v2\x1a.connector.OperationStatusR\x05value:\x028\x01\"\xc4\x01\n" +
	"\x0fCopyFileRequest\x12D\n" +
	"\x0fsource_endpoint\x18\x01 \x01(\v2\x1b.connector.TransferEndpointR\x0esourceEndpoint\x12N\n" +
	"\x14destination_endpoint\x18\x02 \x01(\v2\x1b.connector.TransferEndpointR\x13destinationEndpoint\x12\x1b\n" +
	"\tfile_path\x18\x03 \x01(\tR\bfilePath\"F\n" +
	"\x10CopyFileResponse\x122\n" +
	"\x06status\x18\x01 \x01(\v2\x1a.connector.OperationStatusR\x06status\"F\n" +
	"\x10UploadFileStatus\x122\n" +
	"\x06status\x18\x01 \x01(\v2\x1a.connector.OperationStatusR\x06status\"i\n" +
	"\x13DownloadFileRequest\x125\n" +
	"\abackend\x18\x01 \x01(\v2\x1b.connector.BackendReferenceR\abackend\x12\x1b\n" +
	"\tfile_path\x18\x02 \x01(\tR\bfilePath\"L\n" +
	"\x14DownloadFileResponse\x124\n" +
	"\tdata_part\x18\x01 \x01(\v2\x17.connector.FileDataPartR\bdataPart*\xd8\x01\n" +
	"\fProtocolType\x12\x1d\n" +
	"\x19PROTOCOL_TYPE_UNSPECIFIED\x10\x00\x12\x17\n" +
	"\x13PROTOCOL_TYPE_LOCAL\x10\x01\x12\x15\n" +
	"\x11PROTOCOL_TYPE_FTP\x10\x02\x12\x16\n" +
	"\x12PROTOCOL_TYPE_FTPS\x10\x03\x12\x16\n" +
	"\x12PROTOCOL_TYPE_SFTP\x10\x04\x12\x16\n" +
	"\x12PROTOCOL_TYPE_HTTP\x10\x05\x12\x17\n" +
	"\x13PROTOCOL_TYPE_HTTPS\x10\x06\x12\x18\n" +
	"\x14PROTOCOL_TYPE_GDRIVE\x10\a2\xb0\x06\n" +
	"\x13FileTransferService\x12R\n" +
	"\rListDirectory\x12\x1f.connector.ListDirectoryRequest\x1a .connector.ListDirectoryResponse\x12X\n" +
	"\x0fCreateDirectory\x12!.connector.CreateDirectoryRequest\x1a\".connector.CreateDirectoryResponse\x12j\n" +
	"\x15DeleteFileOrDirectory\x12'.connector.DeleteFileOrDirectoryRequest\x1a(.connector.DeleteFileOrDirectoryResponse\x12j\n" +
	"\x15RenameFileOrDirectory\x12'.connector.RenameFileOrDirectoryRequest\x1a(.connector.RenameFileOrDirectoryResponse\x12[\n" +
	"\x10ScatterDirectory\x12\".connector.ScatterDirectoryRequest\x1a#.connector.ScatterDirectoryResponse\x12X\n" +
	"\x0fGatherDirectory\x12!.connector.GatherDirectoryRequest\x1a\".connector.GatherDirectoryResponse\x12C\n" +
	"\bCopyFile\x12\x1a.connector.CopyFileRequest\x1a\x1b.connector.CopyFileResponse\x12D\n" +
	"\n" +
	"UploadFile\x12\x17.connector.FileDataPart\x1a\x1b.connector.UploadFileStatus(\x01\x12Q\n" +
	"\fDownloadFile\x12\x1e.connector.DownloadFileRequest\x1a\x1f.connector.DownloadFileResponse0\x01B#Z!github.com/jgoldverg/grover/pb;pbb\x06proto3"

var (
	file_transfer_proto_rawDescOnce sync.Once
	file_transfer_proto_rawDescData []byte
)

func file_transfer_proto_rawDescGZIP() []byte {
	file_transfer_proto_rawDescOnce.Do(func() {
		file_transfer_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_transfer_proto_rawDesc), len(file_transfer_proto_rawDesc)))
	})
	return file_transfer_proto_rawDescData
}

var file_transfer_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_transfer_proto_msgTypes = make([]protoimpl.MessageInfo, 36)
var file_transfer_proto_goTypes = []any{
	(ProtocolType)(0),                     // 0: connector.ProtocolType
	(*TlsConfiguration)(nil),              // 1: connector.TlsConfiguration
	(*CredentialReference)(nil),           // 2: connector.CredentialReference
	(*Credential)(nil),                    // 3: connector.Credential
	(*SshCredential)(nil),                 // 4: connector.SshCredential
	(*BasicCredential)(nil),               // 5: connector.BasicCredential
	(*JwtCredential)(nil),                 // 6: connector.JwtCredential
	(*BackendReference)(nil),              // 7: connector.BackendReference
	(*FileMetadata)(nil),                  // 8: connector.FileMetadata
	(*FileTransferMetadata)(nil),          // 9: connector.FileTransferMetadata
	(*FileChunkMetadata)(nil),             // 10: connector.FileChunkMetadata
	(*FileDataPart)(nil),                  // 11: connector.FileDataPart
	(*OperationStatus)(nil),               // 12: connector.OperationStatus
	(*SourceTransferEndpoint)(nil),        // 13: connector.SourceTransferEndpoint
	(*DestinationTransferEndpoint)(nil),   // 14: connector.DestinationTransferEndpoint
	(*TransferEndpoint)(nil),              // 15: connector.TransferEndpoint
	(*FileDestinationAssignment)(nil),     // 16: connector.FileDestinationAssignment
	(*FileSourceAssignment)(nil),          // 17: connector.FileSourceAssignment
	(*ListDirectoryRequest)(nil),          // 18: connector.ListDirectoryRequest
	(*ListDirectoryResponse)(nil),         // 19: connector.ListDirectoryResponse
	(*CreateDirectoryRequest)(nil),        // 20: connector.CreateDirectoryRequest
	(*CreateDirectoryResponse)(nil),       // 21: connector.CreateDirectoryResponse
	(*DeleteFileOrDirectoryRequest)(nil),  // 22: connector.DeleteFileOrDirectoryRequest
	(*DeleteFileOrDirectoryResponse)(nil), // 23: connector.DeleteFileOrDirectoryResponse
	(*RenameFileOrDirectoryRequest)(nil),  // 24: connector.RenameFileOrDirectoryRequest
	(*RenameFileOrDirectoryResponse)(nil), // 25: connector.RenameFileOrDirectoryResponse
	(*ScatterDirectoryRequest)(nil),       // 26: connector.ScatterDirectoryRequest
	(*ScatterDirectoryResponse)(nil),      // 27: connector.ScatterDirectoryResponse
	(*GatherDirectoryRequest)(nil),        // 28: connector.GatherDirectoryRequest
	(*GatherDirectoryResponse)(nil),       // 29: connector.GatherDirectoryResponse
	(*CopyFileRequest)(nil),               // 30: connector.CopyFileRequest
	(*CopyFileResponse)(nil),              // 31: connector.CopyFileResponse
	(*UploadFileStatus)(nil),              // 32: connector.UploadFileStatus
	(*DownloadFileRequest)(nil),           // 33: connector.DownloadFileRequest
	(*DownloadFileResponse)(nil),          // 34: connector.DownloadFileResponse
	nil,                                   // 35: connector.ScatterDirectoryResponse.FileTransferStatusEntry
	nil,                                   // 36: connector.GatherDirectoryResponse.FileGatherStatusEntry
}
var file_transfer_proto_depIdxs = []int32{
	4,  // 0: connector.Credential.ssh:type_name -> connector.SshCredential
	5,  // 1: connector.Credential.basic:type_name -> connector.BasicCredential
	6,  // 2: connector.Credential.jwt:type_name -> connector.JwtCredential
	0,  // 3: connector.BackendReference.protocol:type_name -> connector.ProtocolType
	2,  // 4: connector.BackendReference.credential:type_name -> connector.CredentialReference
	1,  // 5: connector.BackendReference.tls_config:type_name -> connector.TlsConfiguration
	7,  // 6: connector.FileTransferMetadata.source_backend:type_name -> connector.BackendReference
	7,  // 7: connector.FileTransferMetadata.destination_backend:type_name -> connector.BackendReference
	7,  // 8: connector.SourceTransferEndpoint.backend:type_name -> connector.BackendReference
	7,  // 9: connector.DestinationTransferEndpoint.backend:type_name -> connector.BackendReference
	13, // 10: connector.TransferEndpoint.source:type_name -> connector.SourceTransferEndpoint
	14, // 11: connector.TransferEndpoint.destination:type_name -> connector.DestinationTransferEndpoint
	15, // 12: connector.FileDestinationAssignment.destination:type_name -> connector.TransferEndpoint
	15, // 13: connector.FileSourceAssignment.source:type_name -> connector.TransferEndpoint
	7,  // 14: connector.ListDirectoryRequest.backend:type_name -> connector.BackendReference
	8,  // 15: connector.ListDirectoryResponse.files:type_name -> connector.FileMetadata
	7,  // 16: connector.CreateDirectoryRequest.backend:type_name -> connector.BackendReference
	12, // 17: connector.CreateDirectoryResponse.status:type_name -> connector.OperationStatus
	7,  // 18: connector.DeleteFileOrDirectoryRequest.backend:type_name -> connector.BackendReference
	12, // 19: connector.DeleteFileOrDirectoryResponse.status:type_name -> connector.OperationStatus
	7,  // 20: connector.RenameFileOrDirectoryRequest.backend:type_name -> connector.BackendReference
	12, // 21: connector.RenameFileOrDirectoryResponse.status:type_name -> connector.OperationStatus
	15, // 22: connector.ScatterDirectoryRequest.source:type_name -> connector.TransferEndpoint
	16, // 23: connector.ScatterDirectoryRequest.file_assignments:type_name -> connector.FileDestinationAssignment
	35, // 24: connector.ScatterDirectoryResponse.file_transfer_status:type_name -> connector.ScatterDirectoryResponse.FileTransferStatusEntry
	12, // 25: connector.ScatterDirectoryResponse.overall_status:type_name -> connector.OperationStatus
	17, // 26: connector.GatherDirectoryRequest.file_assignments:type_name -> connector.FileSourceAssignment
	15, // 27: connector.GatherDirectoryRequest.destination:type_name -> connector.TransferEndpoint
	36, // 28: connector.GatherDirectoryResponse.file_gather_status:type_name -> connector.GatherDirectoryResponse.FileGatherStatusEntry
	12, // 29: connector.GatherDirectoryResponse.overall_status:type_name -> connector.OperationStatus
	15, // 30: connector.CopyFileRequest.source_endpoint:type_name -> connector.TransferEndpoint
	15, // 31: connector.CopyFileRequest.destination_endpoint:type_name -> connector.TransferEndpoint
	12, // 32: connector.CopyFileResponse.status:type_name -> connector.OperationStatus
	12, // 33: connector.UploadFileStatus.status:type_name -> connector.OperationStatus
	7,  // 34: connector.DownloadFileRequest.backend:type_name -> connector.BackendReference
	11, // 35: connector.DownloadFileResponse.data_part:type_name -> connector.FileDataPart
	12, // 36: connector.ScatterDirectoryResponse.FileTransferStatusEntry.value:type_name -> connector.OperationStatus
	12, // 37: connector.GatherDirectoryResponse.FileGatherStatusEntry.value:type_name -> connector.OperationStatus
	18, // 38: connector.FileTransferService.ListDirectory:input_type -> connector.ListDirectoryRequest
	20, // 39: connector.FileTransferService.CreateDirectory:input_type -> connector.CreateDirectoryRequest
	22, // 40: connector.FileTransferService.DeleteFileOrDirectory:input_type -> connector.DeleteFileOrDirectoryRequest
	24, // 41: connector.FileTransferService.RenameFileOrDirectory:input_type -> connector.RenameFileOrDirectoryRequest
	26, // 42: connector.FileTransferService.ScatterDirectory:input_type -> connector.ScatterDirectoryRequest
	28, // 43: connector.FileTransferService.GatherDirectory:input_type -> connector.GatherDirectoryRequest
	30, // 44: connector.FileTransferService.CopyFile:input_type -> connector.CopyFileRequest
	11, // 45: connector.FileTransferService.UploadFile:input_type -> connector.FileDataPart
	33, // 46: connector.FileTransferService.DownloadFile:input_type -> connector.DownloadFileRequest
	19, // 47: connector.FileTransferService.ListDirectory:output_type -> connector.ListDirectoryResponse
	21, // 48: connector.FileTransferService.CreateDirectory:output_type -> connector.CreateDirectoryResponse
	23, // 49: connector.FileTransferService.DeleteFileOrDirectory:output_type -> connector.DeleteFileOrDirectoryResponse
	25, // 50: connector.FileTransferService.RenameFileOrDirectory:output_type -> connector.RenameFileOrDirectoryResponse
	27, // 51: connector.FileTransferService.ScatterDirectory:output_type -> connector.ScatterDirectoryResponse
	29, // 52: connector.FileTransferService.GatherDirectory:output_type -> connector.GatherDirectoryResponse
	31, // 53: connector.FileTransferService.CopyFile:output_type -> connector.CopyFileResponse
	32, // 54: connector.FileTransferService.UploadFile:output_type -> connector.UploadFileStatus
	34, // 55: connector.FileTransferService.DownloadFile:output_type -> connector.DownloadFileResponse
	47, // [47:56] is the sub-list for method output_type
	38, // [38:47] is the sub-list for method input_type
	38, // [38:38] is the sub-list for extension type_name
	38, // [38:38] is the sub-list for extension extendee
	0,  // [0:38] is the sub-list for field type_name
}

func init() { file_transfer_proto_init() }
func file_transfer_proto_init() {
	if File_transfer_proto != nil {
		return
	}
	file_transfer_proto_msgTypes[2].OneofWrappers = []any{
		(*Credential_Ssh)(nil),
		(*Credential_Basic)(nil),
		(*Credential_Jwt)(nil),
	}
	file_transfer_proto_msgTypes[14].OneofWrappers = []any{
		(*TransferEndpoint_Source)(nil),
		(*TransferEndpoint_Destination)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_transfer_proto_rawDesc), len(file_transfer_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   36,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_transfer_proto_goTypes,
		DependencyIndexes: file_transfer_proto_depIdxs,
		EnumInfos:         file_transfer_proto_enumTypes,
		MessageInfos:      file_transfer_proto_msgTypes,
	}.Build()
	File_transfer_proto = out.File
	file_transfer_proto_goTypes = nil
	file_transfer_proto_depIdxs = nil
}
