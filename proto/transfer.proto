syntax = "proto3";

package connector;

option go_package = "github.com/jgoldverg/grover/pb;pb";

//
// Enumerations
//

enum ProtocolType {
  PROTOCOL_TYPE_UNSPECIFIED = 0;
  PROTOCOL_TYPE_LOCAL = 1;
  PROTOCOL_TYPE_FTP = 2;
  PROTOCOL_TYPE_FTPS = 3;
  PROTOCOL_TYPE_SFTP = 4;
  PROTOCOL_TYPE_HTTP = 5;
  PROTOCOL_TYPE_HTTPS = 6;
  PROTOCOL_TYPE_GDRIVE = 7;
}

//
// TLS configuration for secure connections
//

message TlsConfiguration {
  bool enabled = 1;
  bytes ca_certificate_pem = 2;
  bytes client_certificate_pem = 3;
  bytes client_key_pem = 4;
  bool insecure_skip_verify = 5;
}

//
// Credential messages
//

message CredentialReference {
  string credential_id = 1;  // Unique ID for stored credential
}

message Credential {
  string id = 1;

  oneof credential_type {
    SshCredential ssh = 2;
    BasicCredential basic = 3;
    JwtCredential jwt = 4;
  }
}

message SshCredential {
  bytes private_key_pem = 1;
  string passphrase = 2;
  bytes public_key_pem = 3;
  string username = 4;
}

message BasicCredential {
  string username = 1;
  string password = 2;
}

message JwtCredential {
  string token = 1;
}

//
// Backend reference with credential reference and TLS config
//

message BackendReference {
  ProtocolType protocol = 1;
  string connection_url = 2;
  string backend_name = 3;
  CredentialReference credential = 4;
  TlsConfiguration tls_config = 5;
}

//
// File metadata for directory listings
//

message FileMetadata {
  string file_name = 1;
  int64 file_size_bytes = 2;
  bool is_directory = 3;
  int64 modification_time_unix = 4;
}

//
// File transfer metadata common to all chunks of a file
//

message FileTransferMetadata {
  string source_file_path = 1;
  string destination_file_path = 2;
  string source_server_name = 3;
  string destination_server_name = 4;
  BackendReference source_backend = 5;
  BackendReference destination_backend = 6;
}

//
// File chunk metadata describing a portion of a file
//

message FileChunkMetadata {
  string chunk_id = 1;
  int64 start_byte_index = 2;
  int64 end_byte_index = 3;
  int64 chunk_size_bytes = 4;
  string direct_access_url = 5;
}

//
// File part message containing actual binary data for streaming transfers
//

message FileDataPart {
  string chunk_id = 1;
  int64 offset_in_chunk = 2;
  bytes data = 3;
}

//
// Standard status response
//

message OperationStatus {
  bool success = 1;
  string message = 2;
}

//
// Transfer endpoint definitions with explicit source or destination role
//

message SourceTransferEndpoint {
  BackendReference backend = 1;
  string file_path = 2;
}

message DestinationTransferEndpoint {
  BackendReference backend = 1;
  string file_path = 2;
}

message TransferEndpoint {
  oneof endpoint_type {
    SourceTransferEndpoint source = 1;
    DestinationTransferEndpoint destination = 2;
  }
}

//
// Per-file destination assignment for scatter operations
//

message FileDestinationAssignment {
  string file_path = 1;                 // Path of the file (relative to root)
  TransferEndpoint destination = 2;    // Where this file should be copied/scattered to
}

//
// Per-file source assignment for gather operations
//

message FileSourceAssignment {
  string file_path = 1;               // File to gather
  TransferEndpoint source = 2;        // Where to gather this file from
}

//
// Request and response message definitions
//

message ListDirectoryRequest {
  BackendReference backend = 1;
  string directory_path = 2;
}

message ListDirectoryResponse {
  repeated FileMetadata files = 1;
}

message CreateDirectoryRequest {
  BackendReference backend = 1;
  string directory_path = 2;
}

message CreateDirectoryResponse {
  OperationStatus status = 1;
}

message DeleteFileOrDirectoryRequest {
  BackendReference backend = 1;
  string path = 2;
}

message DeleteFileOrDirectoryResponse {
  OperationStatus status = 1;
}

message RenameFileOrDirectoryRequest {
  BackendReference backend = 1;
  string old_path = 2;
  string new_path = 3;
}

message RenameFileOrDirectoryResponse {
  OperationStatus status = 1;
}

//
// Scatter files in a directory across multiple destinations with explicit mapping
//

message ScatterDirectoryRequest {
  TransferEndpoint source = 1;                             // Source directory
  repeated FileDestinationAssignment file_assignments = 2; // Explicit file-to-destination mapping
  int64 desired_chunk_size_bytes = 3;                      // Optional chunk size for large files
}

message ScatterDirectoryResponse {
  map<string, OperationStatus> file_transfer_status = 1;  // file_path -> status
  OperationStatus overall_status = 2;
}

//
// Gather files from multiple sources to one destination with explicit mapping
//

message GatherDirectoryRequest {
  repeated FileSourceAssignment file_assignments = 1;    // File-to-source mappings
  TransferEndpoint destination = 2;                       // Destination backend
}

message GatherDirectoryResponse {
  map<string, OperationStatus> file_gather_status = 1;   // file_path -> status
  OperationStatus overall_status = 2;
}

//
// Copy a single file from source to destination
//

message CopyFileRequest {
  TransferEndpoint source_endpoint = 1;
  TransferEndpoint destination_endpoint = 2;
  string file_path = 3;
}

message CopyFileResponse {
  OperationStatus status = 1;
}

//
// Upload/Download streaming file data
//

message UploadFileStatus {
  OperationStatus status = 1;
}

message DownloadFileRequest {
  BackendReference backend = 1;
  string file_path = 2;
}

message DownloadFileResponse {
  FileDataPart data_part = 1;
}

//
// Service definition
//

service FileTransferService {
  rpc ListDirectory(ListDirectoryRequest) returns (ListDirectoryResponse);
  rpc CreateDirectory(CreateDirectoryRequest) returns (CreateDirectoryResponse);
  rpc DeleteFileOrDirectory(DeleteFileOrDirectoryRequest) returns (DeleteFileOrDirectoryResponse);
  rpc RenameFileOrDirectory(RenameFileOrDirectoryRequest) returns (RenameFileOrDirectoryResponse);

  rpc ScatterDirectory(ScatterDirectoryRequest) returns (ScatterDirectoryResponse);
  rpc GatherDirectory(GatherDirectoryRequest) returns (GatherDirectoryResponse);

  rpc CopyFile(CopyFileRequest) returns (CopyFileResponse);

  rpc UploadFile(stream FileDataPart) returns (UploadFileStatus);
  rpc DownloadFile(DownloadFileRequest) returns (stream DownloadFileResponse);
}
